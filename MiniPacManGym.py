# -*- coding: utf-8 -*-
"""MiniPacManGym.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hqhWg_BjY5ZGHIPNUG8jcXVeO9kEz9SH
"""

import numpy as np
import gymnasium as gym
from gymnasium import spaces

def MakeWinnableState():
    state = np.zeros((6,6), dtype=np.float32)
    ghost_positions = np.array([[1,2],[2,1],[2,3],[3,2],[1,4],[4,1],[3,4],[4,3]])
    ghost = ghost_positions[np.random.choice(np.arange(8))]
    state[1,1] = 1   # Pacman
    state[ghost[0], ghost[1]] = -1  # Ghost
    return state

def MakeFrozenState():
    state = np.zeros((6,6), dtype=np.float32)
    state[1,1] = 1   # Pacman
    state[2, 3] = -1  # Ghost--change this for different initial positions
    return state

def UpdateGhost(state):
    nextstate = np.copy(state)
    pacman_pos = np.argwhere(state == 1)[0]   # Pacman position
    ghost_pos = np.argwhere(state == -1)[0]   # Ghost position
    nextstate[ghost_pos[0], ghost_pos[1]] = 0 # Remove old ghost

    diff = np.sign(ghost_pos - pacman_pos)
    # Randomly choose one dimension to move in (if diff!=0 along that dimension).
    i = np.random.choice(np.array([0,1])[diff != 0])
    ghost_pos[i] -= diff[i]  # move ghost closer
    nextstate[ghost_pos[0], ghost_pos[1]] = -1
    return nextstate

def NextState(state, action):
    nextstate = np.copy(state)
    pacman_pos = np.argwhere(state == 1)[0]
    nextstate[pacman_pos[0], pacman_pos[1]] = 0

    # Actions: 0=up, 1=down, 2=left, 3=right (example interpretation)
    if action == 0: pacman_pos[0] -= 1  # up
    if action == 1: pacman_pos[0] += 1  # down
    if action == 2: pacman_pos[1] -= 1  # left
    if action == 3: pacman_pos[1] += 1  # right

    nextstate[pacman_pos[0], pacman_pos[1]] = 1
    return nextstate

def GetReward(state, action):
    nextstate = NextState(state, action)
    next_pacman_pos = np.argwhere(nextstate == 1)[0]
    old_ghost_pos = np.argwhere(state == -1)[0]

    # Win if you reach power pellet
    if (next_pacman_pos[0] == 4 and next_pacman_pos[1] == 4):
        return 10
    # Hit top/bottom walls
    if next_pacman_pos[0] == 0 or next_pacman_pos[0] == 5:
        return -10
    # Hit left/right walls
    if next_pacman_pos[1] == 0 or next_pacman_pos[1] == 5:
        return -10
    # Ghost collision
    if (next_pacman_pos[0] == old_ghost_pos[0] and
        next_pacman_pos[1] == old_ghost_pos[1]):
        return -10
    return 0

def MakeBoard(state):
    """Return a string representation of the board."""
    pac    = '\u15E7'
    dot    = '\u00B7'
    power  = '\u25EF'
    ghost  = '\u15E3'
    wall   = 'x'

    board = []
    for i in range(6):
        board.append([])
        for j in range(6):
            board[i].append(dot)

    # Add walls
    for i in range(6):
        board[0][i] = wall
        board[5][i] = wall
        board[i][0] = wall
        board[i][5] = wall

    # Place Pacman
    pac_pos = np.argwhere(state == 1)[0]
    board[pac_pos[0]][pac_pos[1]] = pac

    # Place Ghost
    ghost_pos = np.argwhere(state == -1)[0]
    board[ghost_pos[0]][ghost_pos[1]] = ghost

    # Place Power Pellet
    board[4][4] = power

    # Build the output string
    out = ''
    for i in range(6):
        out += ''.join(board[i]) + '\n'
    return out

class MiniPacManEnv(gym.Env):
    """
    A simple PacMan-like environment for demonstration.
    """
    metadata = {"render_modes": ["human"], "render_fps": 4}

    def __init__(self, render_mode=None, frozen_ghost=False):
        super().__init__()

        # We have four discrete actions (up, down, left, right).
        self.action_space = spaces.Discrete(4)

        # The state is a 6x6 grid with values in [-1, 0, 1].
        # For safety, we can set the Box range to something like [-1.0, 1.0].
        self.observation_space = spaces.Box(
            low=-1.0,
            high=1.0,
            shape=(6, 6),
            dtype=np.float32
        )

        self.state = None
        self.frozen_ghost = frozen_ghost
        self.render_mode = render_mode
        self.terminated = False
        self.truncated = False
        self._max_episode_steps = 20  # Example cap to avoid infinite games.
        self.current_step = 0

    def reset(self, seed=None, options=None):
        # Standard Gymnasium reset signature
        super().reset(seed=seed)
        if self.frozen_ghost:
          self.state = MakeFrozenState()
        else:
          self.state = MakeWinnableState()
        self.terminated = False
        self.truncated = False
        self.current_step = 0

        # Return the initial state and an empty info dict
        return self.state, {}

    def step(self, action):
        # Calculate reward
        reward = GetReward(self.state, action)
        # Update state
        self.state = NextState(self.state, action)

        self.terminated = (abs(reward) == 10)
        self.current_step += 1

        # If not terminated by reward, move the ghost
        if not self.terminated and not self.frozen_ghost:
            self.state = UpdateGhost(self.state)

        # Also check if we are truncating by step limit
        if self.current_step >= self._max_episode_steps:
            self.truncated = True

        return self.state, reward, self.terminated, self.truncated, {}

    def render(self):
        if self.render_mode == "human":
            print(MakeBoard(self.state))
        else:
            pass  # You could return a board array, an image, etc.

    def close(self):
        pass

